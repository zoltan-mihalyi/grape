<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js\grape\class.js - grape</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="grape"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Grape.html">Grape</a></li>
            
                <li><a href="../classes/Grape.AABB.html">Grape.AABB</a></li>
            
                <li><a href="../classes/Grape.AbstractView.html">Grape.AbstractView</a></li>
            
                <li><a href="../classes/Grape.Alarm.html">Grape.Alarm</a></li>
            
                <li><a href="../classes/Grape.Animation.html">Grape.Animation</a></li>
            
                <li><a href="../classes/Grape.Array.html">Grape.Array</a></li>
            
                <li><a href="../classes/Grape.Audio.html">Grape.Audio</a></li>
            
                <li><a href="../classes/Grape.Bag.html">Grape.Bag</a></li>
            
                <li><a href="../classes/Grape.Cacheable.html">Grape.Cacheable</a></li>
            
                <li><a href="../classes/Grape.Class.html">Grape.Class</a></li>
            
                <li><a href="../classes/Grape.Collidable.html">Grape.Collidable</a></li>
            
                <li><a href="../classes/Grape.CollisionSystem.html">Grape.CollisionSystem</a></li>
            
                <li><a href="../classes/Grape.Env.html">Grape.Env</a></li>
            
                <li><a href="../classes/Grape.EventEmitter.html">Grape.EventEmitter</a></li>
            
                <li><a href="../classes/Grape.Game.html">Grape.Game</a></li>
            
                <li><a href="../classes/Grape.GameLoop.html">Grape.GameLoop</a></li>
            
                <li><a href="../classes/Grape.GameObject.html">Grape.GameObject</a></li>
            
                <li><a href="../classes/Grape.GameObjectArray.html">Grape.GameObjectArray</a></li>
            
                <li><a href="../classes/Grape.GUIView.html">Grape.GUIView</a></li>
            
                <li><a href="../classes/Grape.Input.html">Grape.Input</a></li>
            
                <li><a href="../classes/Grape.JSONSceneSource.html">Grape.JSONSceneSource</a></li>
            
                <li><a href="../classes/Grape.Layer.html">Grape.Layer</a></li>
            
                <li><a href="../classes/Grape.Mouse.html">Grape.Mouse</a></li>
            
                <li><a href="../classes/Grape.Object.html">Grape.Object</a></li>
            
                <li><a href="../classes/Grape.Physical.html">Grape.Physical</a></li>
            
                <li><a href="../classes/Grape.Position.html">Grape.Position</a></li>
            
                <li><a href="../classes/Grape.Rectangle.html">Grape.Rectangle</a></li>
            
                <li><a href="../classes/Grape.Resource.html">Grape.Resource</a></li>
            
                <li><a href="../classes/Grape.ResourceCollection.html">Grape.ResourceCollection</a></li>
            
                <li><a href="../classes/Grape.Scene.html">Grape.Scene</a></li>
            
                <li><a href="../classes/Grape.Sprite.html">Grape.Sprite</a></li>
            
                <li><a href="../classes/Grape.SpriteVisualizer.html">Grape.SpriteVisualizer</a></li>
            
                <li><a href="../classes/Grape.System.html">Grape.System</a></li>
            
                <li><a href="../classes/Grape.TagContainer.html">Grape.TagContainer</a></li>
            
                <li><a href="../classes/Grape.Taggable.html">Grape.Taggable</a></li>
            
                <li><a href="../classes/Grape.Utils.html">Grape.Utils</a></li>
            
                <li><a href="../classes/Grape.View.html">Grape.View</a></li>
            
                <li><a href="../classes/Grape.Visualizer.html">Grape.Visualizer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js\grape\class.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//TODOv2 duplicated methods with different modifiers
define([&#x27;./utils&#x27;], function (Utils) {
    var nextId = 0;
    var registeredKeywords = {};

    /**
     * A fake class to represent default class methods
     *
     * @class Grape.Object
     */
    var classMethods = {
        /**
         * Tells whether the given class is a parent of the current class.
         *
         * @method extends
         * @static
         * @param {Class} clazz The class
         * @return {boolean} true, if the given class is a parent
         */
        extends: function (clazz) {
            return !!this.allParentId[clazz.id];
        },
        /**
         * Creates a new class, which extends this class. X.extend(a, b) is the same as Grape.Class(a,X,b)
         *
         * @method extend
         * @static
         * @param {String} [name] The class name
         * @param {Object} [methods] Class methods
         * @return {Class} The new class
         */
        extend: function (name, methods) {
            if (typeof name === &#x27;string&#x27;) { //name given
                if (methods) { //avoid undefined arguments
                    return Class(name, this, methods);
                } else {
                    return Class(name, this);
                }
            } else {
                if (name) { //avoid undefined arguments
                    return Class(this, name);
                } else {
                    return Class(this);
                }
            }
        }
    };

    var instanceMethods = {
        /**
         * Tells that the current instance is an instance of a class, or it&#x27;s descendants.
         *
         * @method instanceOf
         * @param {Class} clazz
         * @return {boolean} true, if yes.
         */
        instanceOf: function (clazz) {
            return (this instanceof clazz) || !!this.getClass().allParentId[clazz.id];
        },
        /**
         * Creates a proxy for calling a parent method
         *
         * @method parent
         * @param {Class} clazz The parent, whose method will be called
         * @param {String} method Method name
         * @return {Function} Method proxy. When called, calls the parent method with the parameters, and original
         * context.
         */
        parent: function (clazz, method) {
            if (!this.instanceOf(clazz)) {
                throw new Error(&#x27;Accessing parent member of not inherited class&#x27;);
            }
            var m = clazz.prototype[method], that = this;
            if (Utils.isFunction(m)) {
                return function () {
                    return m.apply(that, arguments);
                };
            } else {
                return m;
            }
        },
        /**
         * Returns the instance&#x27;s constructor class
         *
         * @method getClass
         * @return {Class}
         */
        getClass: function () {
            return this.constructor;
        }
    };

    function empty() {
    }

    /**
     * A static class for storing keyword related functions. To see how to create a class, check the Class method in the
     * Grape class.
     *
     * @class Grape.Class
     */

    /**
     * Creates a class by optionally copying prototype methods of one or more class.
     *
     * @for Grape
     * @method Class
     * @static
     * @param {String} [name] The name of the class (mainly for debugging purposes)
     * @param {Array|Class} [parents] Parent class or classes
     * @param {Object} methods An object containing methods. If method name contains space, the keyword parts are parsed
     * and keyword specific tasks are executed.
     * @return {*}
     */
    function Class(name, parents, methods) {
        var classInfo = {}, constructor, i, id = ++nextId;

        for (i = 0; i &lt; arguments.length; i++) {
            if (typeof arguments[i] === &#x27;undefined&#x27;) {
                throw new Error(&#x27;Argument is undefined: &#x27; + i);
            }
        }
        //parameter transformations
        if (typeof name !== &#x27;string&#x27;) { //no name
            methods = parents;
            parents = name;
            name = &#x27;Class #&#x27; + id;
        }
        if (!Utils.isArray(parents)) {
            if (Utils.isFunction(parents)) { //single parent
                parents = [parents];
            } else { //no parent
                methods = parents;
                parents = [];
            }

        }
        if (!methods) { //no methods
            methods = {};
        }


        /**
         * The name of the class if set, or a generated string.
         *
         * @for Grape.Object
         * @property className
         * @static
         * @type {String}
         */
        classInfo.className = name;

        /**
         * An unique number for the class, mainly for indexing purposes
         *
         * @for Grape.Object
         * @property id
         * @static
         * @type {Number}
         */
        classInfo.id = id;

        for (i in classMethods) { //plugins can use &#x27;extends&#x27; check
            classInfo[i] = classMethods[i];
        }

        createParentInfo(classInfo, parents);
        createMethodDescriptors(classInfo, methods);

        initializeKeywords(classInfo);

        addParentMethods(classInfo); //left to right order
        addOwnMethods(classInfo);

        createConstructor(classInfo);

        finishKeywords(classInfo);

        constructor = classInfo.constructor;
        //extend prototype with methods
        for (i in classInfo.methods) {
            if (instanceMethods.hasOwnProperty(i)) {
                throw new Error(&#x27;The method name &quot;&#x27; + i + &#x27;&quot; is reserved&#x27;);
            }
            constructor.prototype[i] = classInfo.methods[i];
        }
        //extend constructor with class info
        for (i in classInfo) {
            constructor[i] = classInfo[i];
        }

        for (i in instanceMethods) {
            constructor.prototype[i] = instanceMethods[i];
        }

        constructor.prototype.init = constructor;
        constructor.toString = function () { //debug info
            return name;
        };

        constructor.prototype.constructor = constructor;

        return constructor;
    }

    function createParentInfo(classInfo, parents) {
        var i;
        classInfo.parents = parents;
        classInfo.allParent = getAllParent(parents);
        classInfo.allParentId = {};
        for (i = 0; i &lt; classInfo.allParent.length; i++) {
            classInfo.allParentId[classInfo.allParent[i].id] = true;
        }
    }

    function createMethodDescriptors(classInfo, methods) {
        var methodDescriptors = {}, m;

        for (m in methods) {
            methodDescriptors[m] = parseMethod(m, methods[m], classInfo);
        }
        classInfo.methodDescriptors = methodDescriptors;
        classInfo.methods = {};
        classInfo.ownMethods = {};
        classInfo.init = null;
    }

    /*
     * We create a custom function for performance and debugging reasons.
     */
    function createConstructor(classInfo) {
        /*jslint evil: true */
        var name = classInfo.className, initMethods = [], factory = [], i, parent, constructor;
        //add parent init methods
        for (i = 0; i &lt; classInfo.allParent.length; i++) {
            parent = classInfo.allParent[i];
            if (parent.init) {
                initMethods.push(parent.init);
            }
        }
        //add own init method
        if (classInfo.init) {
            initMethods.push(classInfo.init);
        }

        for (i = 0; i &lt; initMethods.length; i++) {
            factory.push(&#x27;var init&#x27; + i + &#x27; = inits[&#x27; + i + &#x27;];&#x27;); //var init0 = inits[0];
        }

        //With this trick we can see the name of the class while debugging.
        factory.push(&#x27;this[&quot;&#x27; + name + &#x27;&quot;] = function(){&#x27;); //this[&quot;MyClass&quot;] = function(){
        for (i = 0; i &lt; initMethods.length; i++) {
            factory.push(&#x27;init&#x27; + i + &#x27;.apply(this, arguments);&#x27;); //init0.apply(this, arguments)
        }
        factory.push(&#x27;};&#x27;);
        factory.push(&#x27;return this[&quot;&#x27; + name + &#x27;&quot;];&#x27;); //return this[&quot;MyClass&quot;];
        constructor = (new Function(&#x27;inits&#x27;, factory.join(&#x27;\n&#x27;))).call({}, initMethods);
        classInfo.constructor = constructor;
    }

    function initializeKeywords(classInfo) {
        var keyword;
        for (keyword in registeredKeywords) {
            (registeredKeywords[keyword].onInit || empty)(classInfo);
        }
    }

    function finishKeywords(classInfo) {
        var keyword;
        for (keyword in registeredKeywords) {
            (registeredKeywords[keyword].onFinish || empty)(classInfo);
        }
    }

    function addParentMethods(classInfo) {
        var i = 0, allParent = classInfo.allParent, parentsNum = allParent.length, parent, m;
        for (; i &lt; parentsNum; i++) {
            parent = allParent[i];
            for (m in parent.ownMethods) {
                classInfo.methods[m] = parent.ownMethods[m];
            }
        }
    }

    function addOwnMethods(classInfo) {
        var m, methodDescriptors = classInfo.methodDescriptors, methodDescriptor, modifiers, i, j, modifier, canAdd;
        for (m in methodDescriptors) {
            methodDescriptor = methodDescriptors[m];
            if (methodDescriptor.init) {
                classInfo.init = methodDescriptor.method;
            } else {

                modifiers = methodDescriptor.modifiers;
                canAdd = true;
                for (i = 0; i &lt; modifiers.length; i++) {
                    modifier = modifiers[i];
                    if (registeredKeywords[modifier]) {
                        //iterate over other modifiers checking compatibility
                        for (j = i + 1; j &lt; modifiers.length; j++) {
                            if (modifier === modifiers[j]) {
                                throw new Error(&#x27;Modifier &quot;&#x27; + modifier + &#x27;&quot; duplicated.&#x27;);
                            }
                            if (!registeredKeywords[modifier].matches[modifiers[j]]) {
                                throw new Error(&#x27;Modifier &quot;&#x27; + modifier + &#x27;&quot; cannot use with &quot;&#x27; + modifiers[j] + &#x27;&quot;.&#x27;);
                            }
                        }

                        if ((registeredKeywords[modifier].onAdd)(classInfo, methodDescriptor) === false) {
                            canAdd = false;
                        }
                    } else {
                        throw new Error(&#x27;Unknown modifier &quot;&#x27; + modifier + &#x27;&quot;&#x27;);
                    }
                }
                if (canAdd) {
                    classInfo.methods[methodDescriptor.name] = methodDescriptor.method;
                    classInfo.ownMethods[methodDescriptor.name] = methodDescriptor.method;
                }
            }
        }
    }

    function parseMethod(name, method, source) {
        var all = name.split(&#x27; &#x27;),
            modifiers = all.slice(0, -1),
            realName = all.slice(-1)[0],
            is = {},
            init = false,
            i;

        if (realName === &#x27;init&#x27;) {
            init = true;
            if (modifiers.length !== 0) {
                throw new Error(&#x27;init method cannot be marked with any modifiers.&#x27;);
            }
        }

        for (i = modifiers.length - 1; i &gt;= 0; i--) {
            is[modifiers[i]] = true;
        }

        return {
            modifiers: modifiers,
            is: is,
            name: realName,
            method: method,
            source: source,
            init: init
        };
    }

    /*
     * Leftmost iteration of parent tree.
     */
    function getAllParent(parents, directly, acc) {
        var i, parentsNum = parents.length, parent;
        if (!directly) {
            directly = {};
            for (i = 0; i &lt; parentsNum; i++) {
                parent = parents[i];
                if (!parent) {
                    throw new Error(&#x27;Parent #&#x27; + (i + 1) + &#x27; is &#x27; + parent + &#x27;.&#x27;);
                }
                directly[parent.id] = true;
            }
            acc = {
                list: [],
                set: {}
            };
        }
        for (i = 0; i &lt; parentsNum; i++) { //add all parents recursively
            parent = parents[i];
            if (!acc.set[parent.id]) { //not added yet
                getAllParent(parent.parents, directly, acc);
                acc.list.push(parent);
                acc.set[parent.id] = true;
            } else if (directly[parent.id]) { //added directly
                throw new Error(&#x27;Class &quot;&#x27; + parent.className + &#x27;&quot; is set as parent twice, or implied by a parent class&#x27;); //TODOv2 format global string
            }
        }
        return acc.list;
    }

    /**
     * Registers a new keyword (like &#x27;final&#x27; or &#x27;static&#x27;).
     * Todov2 callback params
     *
     * @for Grape.Class
     * @method registerKeyword
     * @static
     * @param {String} name
     * @param {Object} handlers The functions called during the class creation
     * @param {Function} [handlers.onInit] Called when a new class is about to create
     * @param {Function} [handlers.onAdd] Called when a method with the keyword is added to the class
     * @param {Function} [handlers.onFinish] Called when the class is ready
     */
    function registerKeyword(name, handlers) {
        if (registeredKeywords[name]) {
            throw new Error(&#x27;keyword &quot;&#x27; + name + &#x27;&quot; already registered&#x27;);
        }
        handlers.matches = {};
        registeredKeywords[name] = handlers;
    }

    /**
     * Tells to the Grape class system that two keywords can be used together. If not explicitly told, a keyword cannot
     * be used with other ones. The order of keywords is irrelevant.
     *
     * @for Grape.Class
     * @static
     * @method registerKeywordMatching
     * @param {String} k1 Keyword 1
     * @param {String} k2 Keyword 2
     */
    function registerKeywordMatching(k1, k2) {
        registeredKeywords[k1].matches[k2] = true;
        registeredKeywords[k2].matches[k1] = true;
    }

    registerKeyword(&#x27;static&#x27;, {
        onAdd: function (classInfo, methodDescriptor) {
            if (classInfo[methodDescriptor.name] || classMethods[methodDescriptor.name]) {
                throw new Error(&#x27;Static method &quot;&#x27; + methodDescriptor.name + &#x27;&quot; hides a reserved attribute.&#x27;);
            }
            classInfo[methodDescriptor.name] = methodDescriptor.method;
            return false;
        }
    });

    registerKeyword(&#x27;override&#x27;, {
        onAdd: function (classInfo, methodDescriptor) {
            var i, j, parent;
            if (!classInfo.methods[methodDescriptor.name]) { //we are not overriding an implemented method

                //check for abstract methods
                for (i = 0; i &lt; classInfo.allParent.length; ++i) {
                    parent = classInfo.allParent[i];
                    for (j in parent.abstracts) {
                        if (j === methodDescriptor.name) {
                            return;
                        }
                    }
                }
                //no abstract method found
                throw new Error(&#x27;Method &quot;&#x27; + methodDescriptor.name + &#x27;&quot; does not override a method from its superclass&#x27;);
            }
        }
    });

    registerKeyword(&#x27;abstract&#x27;, {
        onInit: function (classInfo) {
            classInfo.abstracts = {};
            classInfo.isAbstract = false;
        },
        onAdd: function (classInfo, methodDescriptor) {
            classInfo.abstracts[methodDescriptor.name] = methodDescriptor.method;
            classInfo.isAbstract = true;
            if (classInfo.methods[methodDescriptor.name]) { //inherited method with the same name
                throw new Error(&#x27;Method &quot;&#x27; + methodDescriptor.name + &#x27;&quot; cannot be abstract, because it is inherited from a parent.&#x27;);
            }
            return false;
        },
        onFinish: function (classInfo) {
            var i, j, parent, oldToString;
            if (classInfo.isAbstract) {
                //replace constructor, this happens before extending it with anything
                oldToString = classInfo.constructor.toString;
                classInfo.constructor = function () {
                    throw new Error(&#x27;Abstract class &quot;&#x27; + classInfo.className + &#x27;&quot; cannot be instantiated.&#x27;);
                };
                classInfo.constructor.toString = oldToString;
                classInfo.constructor.prototype.constructor = classInfo.constructor;
            }

            //check all abstract parent methods are implemented, inherited, or marked abstract
            for (i = 0; i &lt; classInfo.allParent.length; ++i) {
                parent = classInfo.allParent[i];
                for (j in parent.abstracts) {
                    if (!classInfo.methods[j] &amp;&amp; classInfo.abstracts[j] === undefined) {
                        throw new Error(&#x27;Method &quot;&#x27; + j + &#x27;&quot; is not implemented, inherited, or marked abstract&#x27;); //TODOv2 source?
                    }
                }
            }
        }
    });

    registerKeyword(&#x27;final&#x27;, {
        onInit: function (classInfo) {
            var parent, i, j, parentFinals = {};
            //iterate over parent methods checking not overwrite a final method by inheriting
            for (i = 0; i &lt; classInfo.allParent.length; ++i) {
                parent = classInfo.allParent[i];

                for (j in parent.methods) {
                    if (parentFinals.hasOwnProperty(j) &amp;&amp; parentFinals[j] !== parent.methods[j]) { //overriding final method by inheriting
                        throw new Error(&#x27;Method &quot;&#x27; + j + &#x27;&quot; is final and cannot be overridden by inheriting from &quot;&#x27; + parent.className + &#x27;&quot;&#x27;);
                    }
                }

                for (j in parent.finals) {
                    parentFinals[j] = parent.finals[j];
                }
            }
            classInfo.parentFinals = parentFinals;
            classInfo.finals = {};
        },
        onAdd: function (classInfo, methodDescriptor) {
            classInfo.finals[methodDescriptor.name] = methodDescriptor.method;
        },
        onFinish: function (classInfo) {
            var i;

            for (i in classInfo.parentFinals) {
                if (classInfo.methods[i] !== classInfo.parentFinals[i]) {
                    throw new Error(&#x27;Overriding final method &quot;&#x27; + i + &#x27;&quot;&#x27;);
                }
            }
        }
    });

    registerKeywordMatching(&#x27;final&#x27;, &#x27;override&#x27;);


    Class.registerKeyword = registerKeyword;
    Class.registerKeywordMatching = registerKeywordMatching;

    return Class;
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
